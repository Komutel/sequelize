{
  "version": 3,
  "sources": ["../../../src/dialects/mysql/connection-manager.ts"],
  "sourcesContent": ["import assert from 'assert';\r\nimport { promisify } from 'util';\r\nimport dayjs from 'dayjs';\r\nimport type { createConnection as mysqlCreateConnection, Connection, ConnectionOptions as MySqlConnectionOptions } from 'mysql2';\r\nimport {\r\n  AccessDeniedError, ConnectionError,\r\n  ConnectionRefusedError,\r\n  HostNotFoundError,\r\n  HostNotReachableError, InvalidConnectionError,\r\n} from '../../errors';\r\nimport type { ConnectionOptions, Sequelize } from '../../sequelize.js';\r\nimport { isError, isNodeError } from '../../utils/index.js';\r\nimport { logger } from '../../utils/logger';\r\nimport type { Connection as AbstractConnection } from '../abstract/connection-manager';\r\nimport { AbstractConnectionManager } from '../abstract/connection-manager';\r\n// eslint-disable-next-line import/order\r\nimport type { AbstractDialect } from '../abstract/index.js';\r\n\r\nconst DataTypes = require('../../data-types').mysql;\r\nconst parserStore = require('../parserStore')('mysql');\r\n\r\nconst debug = logger.debugContext('connection:mysql');\r\n\r\n// TODO: once the code has been split into packages, we won't need to lazy load mysql2 anymore\r\ntype Lib = {\r\n  createConnection: typeof mysqlCreateConnection,\r\n  Connection: Connection,\r\n};\r\n\r\nexport type MySqlConnection = Connection & AbstractConnection;\r\n\r\n/**\r\n * MySQL Connection Manager\r\n *\r\n * Get connections, validate and disconnect them.\r\n * AbstractConnectionManager pooling use it to handle MySQL specific connections\r\n * Use https://github.com/sidorares/node-mysql2 to connect with MySQL server\r\n *\r\n * @private\r\n */\r\nexport class MySqlConnectionManager extends AbstractConnectionManager<MySqlConnection> {\r\n  private readonly lib: Lib;\r\n\r\n  constructor(dialect: AbstractDialect, sequelize: Sequelize) {\r\n    super(dialect, sequelize);\r\n    this.lib = this._loadDialectModule('mysql2') as Lib;\r\n    this.refreshTypeParser(DataTypes);\r\n  }\r\n\r\n  _refreshTypeParser(dataType: unknown): void {\r\n    parserStore.refresh(dataType);\r\n  }\r\n\r\n  _clearTypeParser() {\r\n    parserStore.clear();\r\n  }\r\n\r\n  #typecast(field: any, next: () => void): void {\r\n    if (parserStore.get(field.type)) {\r\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\r\n    }\r\n\r\n    return next();\r\n  }\r\n\r\n  /**\r\n   * Connect with MySQL database based on config, Handle any errors in connection\r\n   * Set the pool handlers on connection.error\r\n   * Also set proper timezone once connection is connected.\r\n   *\r\n   * @param config\r\n   * @returns\r\n   * @private\r\n   */\r\n  async connect(config: ConnectionOptions): Promise<MySqlConnection> {\r\n    assert(typeof config.port === 'number', 'port has not been normalized');\r\n\r\n    const connectionConfig: MySqlConnectionOptions = {\r\n      bigNumberStrings: false,\r\n      supportBigNumbers: true,\r\n      flags: ['-FOUND_ROWS'],\r\n      ...config.dialectOptions,\r\n      ...(config.host == null ? null : { host: config.host }),\r\n      port: config.port,\r\n      ...(config.username == null ? null : { user: config.username }),\r\n      ...(config.password == null ? null : { password: config.password }),\r\n      ...(config.database == null ? null : { database: config.database }),\r\n      ...(!this.sequelize.options.timezone ? null : { timezone: this.sequelize.options.timezone }),\r\n      typeCast: (field, next) => this.#typecast(field, next),\r\n    };\r\n\r\n    try {\r\n      const connection: MySqlConnection = await createConnection(this.lib, connectionConfig);\r\n\r\n      debug('connection acquired');\r\n\r\n      connection.on('error', (error: unknown) => {\r\n        if (!isNodeError(error)) {\r\n          return;\r\n        }\r\n\r\n        switch (error.code) {\r\n          case 'ESOCKET':\r\n          case 'ECONNRESET':\r\n          case 'EPIPE':\r\n          case 'PROTOCOL_CONNECTION_LOST':\r\n            void this.pool.destroy(connection);\r\n            break;\r\n          default:\r\n        }\r\n      });\r\n\r\n      if (!this.sequelize.config.keepDefaultTimezone && this.sequelize.options.timezone) {\r\n        // set timezone for this connection\r\n        // but named timezone are not directly supported in mysql, so get its offset first\r\n        let tzOffset = this.sequelize.options.timezone;\r\n        tzOffset = tzOffset.includes('/') ? dayjs.tz(undefined, tzOffset).format('Z') : tzOffset;\r\n        await promisify(cb => connection.query(`SET time_zone = '${tzOffset}'`, cb))();\r\n      }\r\n\r\n      return connection;\r\n    } catch (error) {\r\n      if (!isError(error)) {\r\n        throw error;\r\n      }\r\n\r\n      const code = isNodeError(error) ? error.code : null;\r\n\r\n      switch (code) {\r\n        case 'ECONNREFUSED':\r\n          throw new ConnectionRefusedError(error);\r\n        case 'ER_ACCESS_DENIED_ERROR':\r\n          throw new AccessDeniedError(error);\r\n        case 'ENOTFOUND':\r\n          throw new HostNotFoundError(error);\r\n        case 'EHOSTUNREACH':\r\n          throw new HostNotReachableError(error);\r\n        case 'EINVAL':\r\n          throw new InvalidConnectionError(error);\r\n        default:\r\n          throw new ConnectionError(error);\r\n      }\r\n    }\r\n  }\r\n\r\n  async disconnect(connection: MySqlConnection) {\r\n    // @ts-expect-error -- undeclared var\r\n    if (connection._closing) {\r\n      debug('connection tried to disconnect but was already at CLOSED state');\r\n\r\n      return;\r\n    }\r\n\r\n    await promisify(callback => connection.end(callback))();\r\n  }\r\n\r\n  validate(connection: MySqlConnection) {\r\n    return connection\r\n      // @ts-expect-error -- undeclared var\r\n      && !connection._fatalError\r\n      // @ts-expect-error -- undeclared var\r\n      && !connection._protocolError\r\n      // @ts-expect-error -- undeclared var\r\n      && !connection._closing\r\n      // @ts-expect-error -- undeclared var\r\n      && !connection.stream.destroyed;\r\n  }\r\n}\r\n\r\nasync function createConnection(\r\n  lib: Lib,\r\n  config: MySqlConnectionOptions,\r\n): Promise<MySqlConnection> {\r\n  return new Promise((resolve, reject) => {\r\n    const connection: MySqlConnection = lib.createConnection(config) as MySqlConnection;\r\n\r\n    const errorHandler = (e: unknown) => {\r\n      // clean up connect & error event if there is error\r\n      connection.removeListener('connect', connectHandler);\r\n      connection.removeListener('error', connectHandler);\r\n      reject(e);\r\n    };\r\n\r\n    const connectHandler = () => {\r\n      // clean up error event if connected\r\n      connection.removeListener('error', errorHandler);\r\n      resolve(connection);\r\n    };\r\n\r\n    // don't use connection.once for error event handling here\r\n    // mysql2 emit error two times in case handshake was failed\r\n    // first error is protocol_lost and second is timeout\r\n    // if we will use `once.error` node process will crash on 2nd error emit\r\n    connection.on('error', errorHandler);\r\n    connection.once('connect', connectHandler);\r\n  });\r\n}\r\n"],
  "mappings": "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",
  "names": ["assert", "dayjs"]
}
